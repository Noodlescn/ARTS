### 1. Alogrithom
#### Question: [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/)

```java
/**
 * Definition for singly-linked list
 */
 public class ListNode{
     int val;
     ListNode next;
     ListNode(int x){ val = x; }
 }

/**
 * the pseudocode is as following:
 *   1. Initialize current node to dummy head of the returning list.
 *   2. Initialize carry to 0.
 *   3. Initialize p and q to head of l1 and l2 respectively.
 *   4. Loop through lists l1 and l2 until you reach both ends.
 *       4.1 Set x to node p's value. If p has reached the end of l1, set to 0.
 *       4.2 Set y to node q's value. If q has reached the end of l2, set to 0.
 *       4.3 Set sum = x + y + carry.
 *       4.4 Update carry = sum / 10.
 *       4.5 Create a new node with the digit value of(sum mod 10) and set it to current node's
 *        next, then advance current node to next.
 *       4.6 Advance both p and q.
 *    5. Check if carry = 1, if so append a new node with digit 1 to the returning list.
 *    6. Return dummy head's next node.
 */

 public ListNode addTwoNumbers(ListNode l1, ListNode l2){
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    int carry = 0;
    while(p != null || q != null){
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if(p != null) p = p.next;
        if(q != null) q = q.next;
    }
    if(carry > 0){
        curr.next = next ListNode(carry);
    }
    return dummyHead.next;
 }
```

Complexity Analysis:
- Time complexity: O(max(m, n))
- Space complexity: O(max(m, n))

#### Question: [Reverse Integer](https://leetcode.com/problems/reverse-integer/description/)

```java
class Solution{
    public int reverse(int x){
        int rev = 0;
        while(x != 0){
            int pop = x % 10;
            x /= 10;
            if(rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if(rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
}
```

Complexity Analysis:
- Time Complexity: O(log(x))
- Space Complexity: O(1)

### 2. Review



### 3. Tips


### 4. Share
